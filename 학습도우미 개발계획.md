# 학습 도우미 최소 기능 개발 계획서 (인증/다중 사용자 제거 버전)

> 목적: 나 혼자 쓰는 학습 도우미용 할 일 관리 API를 **최소 기능 + 최소 난이도**로 구현하고, Render에 Web Service 하나만 배포해서 GPTs Actions에서 바로 호출할 수 있게 만든다.

---

## 1. 전체 구조 개요

* **나만 사용하는 개인용 API** → 사용자 인증, API Key, /users 엔드포인트 전부 제거
* **단일 서비스 + 단일 DB 파일**

  * 서버: FastAPI + Uvicorn
  * DB: SQLite 파일 하나 (예: `study_assistant.db`)
  * 배포: Render Web Service 1개 (Worker, Cron 전부 없음)
* **만료 처리(EXPIRED 전환)**

  * 별도 워커 없이, `GET /v1/tasks` 호출 시점에 "기한 지난 PENDING"을 자동으로 `EXPIRED`로 업데이트

이 구조로도 원래 계획서의 핵심 기능인:

* 할 일 생성/조회
* GPT가 이미지 판정 후 `APPROVED` 전환
* 만료 시 `EXPIRED` 전환
  을 모두 구현할 수 있다.

---

## 2. 기술 스택

* 언어 / 프레임워크

  * Python 3.11
  * FastAPI (REST API + 자동 OpenAPI 문서)
  * Uvicorn (ASGI 서버)
* 데이터베이스

  * 개발/운영 모두 **SQLite** 사용 (`study_assistant.db`)
  * 나중에 필요하면 PostgreSQL로 교체 가능하도록 SQL 최대한 단순하게 유지
* 배포

  * Render Web Service (Python)
  * Build: `pip install -r requirements.txt`
  * Start: `uvicorn main:app --host 0.0.0.0 --port 10000`

---

## 3. 기능 범위 (인증 제거 후 최소 셋)

### 포함할 기능

1. **할 일 생성**

   * `POST /v1/tasks`
   * 입력: `title`, `verify_method`, `due_at_iso`
   * 출력: `task_id`, `state='PENDING'`

2. **할 일 목록 조회 + 만료 처리**

   * `GET /v1/tasks`
   * 쿼리: `state?`, `q?`, `due_before?`, `due_after?`
   * 동작:

     1. 먼저 DB에서 **현재 시각 기준으로** 기한이 지난 `PENDING`들을 `EXPIRED`로 업데이트
     2. 그 다음 필터 조건에 맞는 목록 조회 후 반환

3. **검증 시도 기록 + 상태 전환**

   * `POST /v1/tasks/{id}/verify-attempt`
   * 입력: `proof_url`, `verdict`, `score?`, `reasons?`, `raw_features?`
   * 동작:

     1. `verification_attempts` 테이블에 항상 시도 로그 저장
     2. `verdict=true`이면 해당 `task`의 상태를 `APPROVED`로 전환
     3. 최종 상태를 응답으로 반환

### 제외하는 기능

* 사용자 인증/인가

  * `X-API-Key`, Bearer 토큰, /internal/cron/expire 전부 제거
* 다중 사용자 관리

  * `users` 테이블, `user_id` 개념 제거
  * 모든 할 일은 "나" 기준의 전역 목록으로 관리
* 별도 워커/크론 서비스

  * Render Worker, Cron 설정 없이 Web Service 하나로 끝

---

## 4. 데이터 모델 (SQLite)

### 4.1 테이블 설계

단일 유저 기준이라 `user_id`가 필요 없고, 전체 구조를 다음 두 테이블로 축소한다.

```sql
CREATE TABLE IF NOT EXISTS tasks (
  id TEXT PRIMARY KEY,                -- uuid 문자열
  title TEXT NOT NULL,                -- 예: "수능특강 물리1 p.10~20"
  verify_method TEXT NOT NULL,        -- 예: "해당 페이지 풀이 촬영"
  due_at TIMESTAMP NOT NULL,         -- UTC 기준 (naive로 저장, 항상 UTC라고 가정)
  state TEXT NOT NULL CHECK (state IN ('PENDING','APPROVED','EXPIRED')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_tasks_state_due ON tasks (state, due_at);

CREATE TABLE IF NOT EXISTS verification_attempts (
  id TEXT PRIMARY KEY,
  task_id TEXT NOT NULL,
  attempted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  proof_url TEXT NOT NULL,           -- GPT가 넘겨주는 이미지/파일 URL
  verdict INTEGER NOT NULL,          -- 0/1 (False/True)
  score REAL,                        -- 판정 신뢰도 (옵션)
  reasons TEXT,                      -- 이유 요약
  raw_features TEXT                  -- JSON 문자열 (추출된 페이지/키워드 등)
);
```

### 4.2 상태 전이 규칙

* 생성 시: `PENDING`
* 검증 성공: `POST /v1/tasks/{id}/verify-attempt` 에서 `verdict=true` → `APPROVED`
* 만료: `GET /v1/tasks` 호출 시, `due_at <= now` 이면서 `state='PENDING'`인 것들을 `EXPIRED`로 업데이트
* `APPROVED` / `EXPIRED` 는 되돌리지 않음 (v0에서는 관리자 롤백 기능 없음)

---

## 5. API 설계 (최소 버전)

### Base

* `Base URL`: `/v1`
* 인증 없음 (공개 엔드포인트, 단 나만 쓴다는 가정)

### 5.1 `POST /v1/tasks` – 할 일 생성

* 요청 예시

```json
{
  "title": "수능특강 물리1 p.10~20",
  "verify_method": "해당 페이지 풀이 촬영",
  "due_at_iso": "2025-11-20T15:00:00Z"
}
```

* 응답 예시

```json
{
  "task_id": "...uuid...",
  "state": "PENDING"
}
```

### 5.2 `GET /v1/tasks` – 목록 조회 + 자동 만료 처리

* 쿼리 파라미터

  * `state` (옵션): `PENDING | APPROVED | EXPIRED`
  * `q` (옵션): 제목 부분 일치 검색용 문자열
  * `due_before` (옵션): ISO 시각, 이 시각 이전 마감인 것만
  * `due_after` (옵션): ISO 시각, 이 시각 이후 마감인 것만

* 동작 순서

  1. 서버 기준 현재 UTC 시각 `now` 계산
  2. `due_at <= now AND state='PENDING'` 인 `tasks` 들을 `EXPIRED`로 업데이트
  3. 필터 조건(state, q, due_before, due_after)에 맞는 할 일을 조회
  4. `due_at`을 ISO(UTC, `Z`) 형태 문자열로 변환해서 반환

* 응답 예시

```json
{
  "items": [
    {
      "id": "...uuid...",
      "title": "수능특강 물리1 p.10~20",
      "verify_method": "해당 페이지 풀이 촬영",
      "due_at_iso": "2025-11-20T15:00:00Z",
      "state": "PENDING"
    }
  ]
}
```

### 5.3 `POST /v1/tasks/{id}/verify-attempt` – 검증 시도 기록

* 요청 예시

```json
{
  "proof_url": "https://.../image.jpg",
  "verdict": true,
  "score": 0.92,
  "reasons": "p.10~20 범위와 일치, 필기 확인",
  "raw_features": {"pages": [10,11,12], "keywords": ["물리1", "p.10"]}
}
```

* 동작

  1. `verification_attempts`에 시도 기록을 남김
  2. `verdict=true`라면 해당 task의 `state`를 `APPROVED`로 업데이트
  3. 최종 `state`를 담아서 응답

* 응답 예시

```json
{
  "task_id": "...uuid...",
  "state": "APPROVED"
}
```

---

## 6. 서버 구현 구조 (최소 파일 구성)

### 6.1 파일 목록

* `main.py`

  * FastAPI 앱 정의
  * SQLite 연결 함수 및 초기화(`init_db`) 호출
  * `/v1/tasks` 관련 라우트 전부 포함
* `schema.sql`

  * 위에 정의한 `CREATE TABLE` 스크립트
* `requirements.txt`

  * `fastapi`
  * `uvicorn[standard]`

필요하면 나중에 `models.py`, `db.py` 등으로 코드를 분리할 수 있지만, v0에서는 `main.py` 하나에 모두 넣어서 단순하게 유지한다.

### 6.2 서버 동작 흐름

1. 앱 시작 시(`startup` 이벤트)

   * `schema.sql` 실행해서 테이블이 없으면 생성
2. 각 요청마다

   * `sqlite3.connect(DB_PATH)`로 커넥션 생성 → 쿼리 실행 → 종료
3. 시간 관련

   * `due_at_iso`는 항상 UTC 기준 ISO 문자열로 파싱/저장
   * 응답에서도 UTC 기준 `...Z` 형태로 반환

---

## 7. Render 배포 계획 (인증 제거 버전)

1. GitHub에 다음 파일 업로드

   * `main.py`
   * `schema.sql`
   * `requirements.txt`
2. Render에서 New Web Service 생성

   * Environment: Python
   * Build Command: `pip install -r requirements.txt`
   * Start Command: `uvicorn main:app --host 0.0.0.0 --port 10000`
3. 배포 후

   * `https://<render-url>/docs` 에 접속해서 FastAPI 자동 문서 확인
   * `https://<render-url>/openapi.json` 을 GPTs Actions에 연결해 사용

---

## 8. 초기 개발 순서 (실제 작업 단계)

1. 로컬 폴더 생성 → `main.py`, `schema.sql`, `requirements.txt` 작성
2. 로컬에서 서버 실행

   * `uvicorn main:app --reload`
   * `http://localhost:8000/docs` 에서 API 테스트
3. 기본 플로우 점검

   1. `POST /v1/tasks` 로 할 일 생성
   2. `GET /v1/tasks` 로 목록 조회 (state, q 필터로 테스트)
   3. `POST /v1/tasks/{id}/verify-attempt` 로 verdict=false/true 케이스 각각 테스트
   4. 기한 지난 task가 `GET /v1/tasks` 요청 시 `EXPIRED`로 바뀌는지 확인
4. GitHub에 푸시 후 Render에 연결해서 배포
5. GPTs Actions에서 Render URL을 사용하도록 설정하고, 실제 챗봇-서버 연동 플로우 테스트

이 계획서 기준으로 구현하면, 원래 계획서의 기능을 유지하면서도 **인증/다중 사용자/워커/마이그레이션을 전부 걷어낸 최소 구현**을 빠르게 만들 수 있다.
